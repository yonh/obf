#+OPTIONS: \n:t
#+STYLE: <link rel="stylesheet" type="text/css" href="/style.css" />
* 书籍数据库程序源码及笔记
** 预备说明
   2014-6-9 21:10
** 正文
此源码本质上源于实用CommonLisp编程的第三章,无意中发现了有人弄出个中文源码版本,哈哈,挺有意思的
想我当初是在第三章的时候就停下了,里面因为部分代码根本无法理解,书中解释也看不懂,无法理解,非常郁闷,就拖下来没看下去了,貌似还有个原因是我找到了个更有意思的程序,就是前面记录的分析lisp解释器源码(该源码也有最后一段没看懂,因为后面解释的东西是我不懂的内容,lambda和label,所以没法继续),现在算有时间了,继续学习lisp,其他什么工作上的知识我就没法照顾你们了

源码来自http://my.oschina.net/freeblues/blog/131557
以下是总结的纯源码和带笔记的源码
(defvar *书籍数据库* 
  '((:书名 "我爸是李刚" :作者 "李刚" :价格 1 :是否有电子版 NIL) (:书名 "床前明月光" :作者 "李白" :价格 1 :是否有电子版 T)))
(defun 建立书籍信息 (书名 作者 价格 是否有电子版)
    (list :书名 书名 :作者 作者 :价格 价格 :是否有电子版 是否有电子版))
(defun 增加记录 (书籍信息)
     (push 书籍信息 *书籍数据库*))
(defun 格式化输出书籍信息1 ()
    (dolist (单条书籍记录 *书籍数据库*)
        (format t "~{~a: ~20t~a~%~}~%" 单条书籍记录)))
(defun 格式化输出书籍信息2 ()
    (format t "~{~{~a: ~20t~a~%~}~%~}" *书籍数据库*))
(defun 提示输入 (提示信息)
    (format *query-io* "~a: " 提示信息)
    (force-output *query-io*)
    (read-line *query-io*))
(defun 提示输入书籍信息 ()
    (建立书籍信息
        (提示输入 "书名")
        (提示输入 "作者")
        (or (parse-integer (提示输入 "价格") :junk-allowed t) 0)
        (y-or-n-p "是否有电子版[y/n]: ")))
(defun 批量输入 ()
    (loop (增加记录 (提示输入书籍信息))
        (if (not (y-or-n-p "还要继续输入下一本书籍的信息吗？[y/n]: ")) (return))))
(defun 保存数据库 (带路径的文件名)
       (with-open-file (文件绑定变量 带路径的文件名 :direction :output :if-exists :supersede)
         (with-standard-io-syntax
           (print *书籍数据库* 文件绑定变量))))
(defun 加载数据库 (带路径的加载文件名)
    (with-open-file (文件绑定变量 带路径的加载文件名)
        (with-standard-io-syntax
            (setf *书籍数据库* (read 文件绑定变量)))))
(defun 查找 (根据?查找函数)
        (remove-if-not
            根据?查找函数
            *书籍数据库*))
(defun 删除 (根据?查找函数)
    (setf *书籍数据库*
        (remove-if 根据?查找函数 *书籍数据库*)))
(defun 域值->表达式 (域 值)
    `(equal (getf 单条记录 ,域) ,值))
(defun 域值->列表 (域值参数对列表)
    (loop while 域值参数对列表
        collecting (域值->表达式 (pop 域值参数对列表) (pop 域值参数对列表))))
(defmacro 筛选条件 (&rest 域值参数对列表)
    `#'(lambda (单条记录) 
            (and ,@(域值->列表 域值参数对列表))))
(defun 更新域值->表达式 (域 值)
  `(setf (getf 单条记录 ,域) ,值))
(defun 更新域值->列表 (域值参数对列表)
    (loop while 域值参数对列表
        collecting (更新域值->表达式 (pop 域值参数对列表) (pop 域值参数对列表))))
(defmacro 更新宏 (根据?查找函数 &rest 域值参数对列表)
    `(setf *书籍数据库*
        (mapcar
            #'(lambda (单条记录)
                (when (funcall ,根据?查找函数 单条记录)
                    ,@(更新域值->列表 域值参数对列表))
                 单条记录) 
            *书籍数据库*)))
-------------------------------------------------------------------------------------------------------

带笔记的源码
 
;;--------------------------------------基础代码------------------------------------------------
;;建立书籍信息函数
(defun 建立书籍信息 (书名 作者 价格 是否有电子版)
    (list :书名 书名 :作者 作者 :价格 价格 :是否有电子版 是否有电子版))
;;call:
;(建立书籍信息 "人间词话" "王国维" 100 t)
;;创建书籍数据库
;(defvar *书籍数据库* nil)
(defvar *书籍数据库* 
  '((:书名 "我爸是李刚" :作者 "李刚" :价格 1 :是否有电子版 NIL)(:书名 "床前明月光" :作者 "李白" :价格 1 :是否有电子版 T)))
;;添加书籍记录
(defun 增加记录 (书籍信息)
     (push 书籍信息 *书籍数据库*))
;;call
;(增加记录 (建立书籍信息 "人间词话" "王国维" 100 t))
;;使用更好看的形式输出*书籍数据库*内容
(defun 格式化输出书籍信息1 ()
    (dolist (单条书籍记录 *书籍数据库*)
        (format t "~{~a: ~20t~a~%~}~%" 单条书籍记录)))
#|
format执行分析
~{  format 的循环语法，表示下一个对应的实参是一个列表的开始，
    然后 format 会在该列表上进行循环操作，处理位于 ~{ 和 ~} 之间的指令，
    每轮循环处理多少个实参取决于 ~{ 和 ~} 之间有多少个对应实参的指令，执行多少轮循环取决于 “单条书籍记录”
    中的元素的个数（确切说：循环轮数 = 元素个数 除以 每轮循环处理实参个数）,所以可以通过使用 ~{ 和 ~} 来实现循环
~}  同上，和 ~{ 配合使用
~a  美化指令，该指令对应一个实参，会把这个实参的显示形式输出为更适合阅读的形式，
    具体说就是形如 :书名 的关键字在输出时会被去掉冒号，形如 "人间词话" 的字符串在输出时会被去掉双引号
~t  表示制表指令，不对应实参，只移动光标，~20t 告诉 format 把光标向后移动 20 列
~%  表示换行，不对应实参
另外要注意   格式指令字符串中所有的非格式指令均以原样输出，比如 ~a 后面的冒号 : 和空格就直接原样输出
(format t "~{~a:------->~20t~a~%~}~%" '(:书名 "人间词话" :作者 "王国维" :价格 100 :是否有电子版 T))
书名:------->         人间词话
作者:------->         王国维
价格:------->         100
是否有电子版:------->     T
|#
;精简了dolist
(defun 格式化输出书籍信息2 ()
    (format t "~{~{~a: ~20t~a~%~}~%~}" *书籍数据库*))
;;提示输入函数,显示提示信息,并返回我们输入的值
(defun 提示输入 (提示信息)
    (format *query-io* "~a: " 提示信息)
    (force-output *query-io*)
    (read-line *query-io*))
#|
调用
(提示输入 "姓名")
姓名: 李白
"李白"
NIL
|#
;;利用提示输入函数构造新的输入书籍信息的接口
(defun 提示输入书籍信息 ()
    (建立书籍信息
        (提示输入 "书名")
        (提示输入 "作者")
        (提示输入 "价格")
        (提示输入 "是否有电子版[y/n]")))
;;健壮的提示输入书籍信息函数
(defun 提示输入书籍信息 ()
    (建立书籍信息
        (提示输入 "书名")
        (提示输入 "作者")
        (or (parse-integer (提示输入 "价格") :junk-allowed t) 0)
        (y-or-n-p "是否有电子版[y/n]: ")))
;;不断循环提示输入书籍信息,直至我们不想输入位置,批量输入函数
(defun 批量输入 ()
    (loop (增加记录 (提示输入书籍信息))
        (if (not (y-or-n-p "还要继续输入下一本书籍的信息吗？[y/n]: ")) (return))))
;;保存数据库内容到文件
(defun 保存数据库 (带路径的文件名)
       (with-open-file (文件绑定变量 带路径的文件名 :direction :output :if-exists :supersede)
         (with-standard-io-syntax
           (print *书籍数据库* 文件绑定变量))))
#|
调用
(保存数据库 "/home/ial92/book.db")
--------函数解释---------------
1）首先，宏with-open-file根据我们输入的参数 带路径的保存文件名打开一个文件，然后将文件流绑定到文件绑定变量上
2）接着会执行一组表达式，就是这个：(with-standard-io-syntax (print *书籍数据库* 文件绑定变量)
3）这组表达式执行的操作如下：宏 with-standard-io-syntax 确保对函数 print 的一致性
   使用—有些特定的变量的值可能会影响函数 print 的行为，现在由宏 with-standard-io-syntax 把这些特定变量
   全部设置为标准值，代码 (print *书籍数据库* 文件绑定变量) 则把 *书籍数据库* 的内容打印到 文件绑定变量 ，
   因为 文件绑定变量 绑定到了我们新打开的文件上，所以实际上就把 *书籍数据库* 的内容写入到文件中了；
4）执行完这组表达式，再由宏 with-open-file 关闭文件。
--------函数解释结束-----------
|#
;;加载数据库文件到数据库,和保存操作刚好相反
(defun 加载数据库 (带路径的加载文件名)
    (with-open-file (文件绑定变量 带路径的加载文件名)
        (with-standard-io-syntax
            (setf *书籍数据库* (read 文件绑定变量)))))
;;实现按照作者名称查询书籍数据库里面的记录,此处需要理解remove-if-not的使用
(remove-if-not #'(lambda (单条记录) (equal (getf 单条记录 :作者) "王国维")) *书籍数据库*)
;;定义按作者名查找函数
(defun 用作者名查找 (作者)
    (remove-if-not
       #'(lambda (单条记录)
            (equal (getf 单条记录 :作者) 作者))
       *书籍数据库*))
;;定义按书名查找函数
(defun 用书名查找 (书名)
    (remove-if-not
       #'(lambda (单条记录)
            (equal (getf 单条记录 :书名) 书名))
       *书籍数据库*))
;;定义按价格查找函数
(defun 用价格查找 (价格)
    (remove-if-not
       #'(lambda (单条记录)
            (equal (getf 单条记录 :价格) 价格))
       *书籍数据库*))
;;定义按是否有电子版查找函数
(defun 用是否有电子版查找 (是否有电子版)
    (remove-if-not
       #'(lambda (单条记录)
            (equal (getf 单条记录 :是否有电子版) 是否有电子版))
       *书籍数据库*))
;;-----------第一次抽象查找函数
;;我们发现上面几个函数结构全部都一样,就用于查询的变量不一样而已,所以我们对此进行抽象
(defun 查找 (根据?查找函数)
        (remove-if-not
            根据?查找函数
            *书籍数据库*))
这样我们以查找函数为基础的,编写选择器
(defun 选择器-书名 (书名)
  #'(lambda (单条记录)
    (equal (getf 单条记录 :书名) 书名)))
(defun 选择器-作者 (作者)
  #'(lambda (单条记录)
    (equal (getf 单条记录 :作者) 作者)))
(defun 选择器-价格 (价格)
  #'(lambda (单条记录)
    (equal (getf 单条记录 :价格) 价格)))
(defun 选择器-是否有电子版 (是否有电子版)
  #'(lambda (单条记录)
    (equal (getf 单条记录 :是否有电子版) 是否有电子版)))
;查询的时候就只要将选择器放进去
(查找 (选择器-书名 "我在美国的故事")) ;按书名查找
(查找 (选择器-价格 1)) ;按价格查找
;;-----------第二次抽象查找函数
;这里我们进行了抽象,筛选条件函数可以自动生成对应的选择器,而不需要编写多个选择器函数
(defun 筛选条件 (&key 书名 作者 价格 (是否有电子版 nil 是否有电子版-p))
  #'(lambda (单条记录)
      (and
    (if 书名 (equal (getf 单条记录 :书名) 书名) t)
    (if 作者 (equal (getf 单条记录 :作者) 作者) t)
    (if 价格 (equal (getf 单条记录 :价格) 价格) t)
    (if 是否有电子版-p (equal (getf 单条记录 :是否有电子版) 是否有电子版) t))))
;call
;(查找 (筛选条件 :是否有电子版 t))
;;更新
(defun 更新 (根据?查找函数 &key 书名 作者 价格 (是否有电子版 nil 是否有电子版-p))
    (setf *书籍数据库*
        (mapcar
            #'(lambda (单条记录)
                (when (funcall 根据?查找函数 单条记录)
                    (if 书名           
                        (setf (getf 单条记录 :书名) 书名))
                    (if 作者           
                        (setf (getf 单条记录 :作者) 作者))
                    (if 价格           
                        (setf (getf 单条记录 :价格) 价格))
                    (if 是否有电子版-p  
                        (setf (getf 单条记录 :是否有电子版) 是否有电子版)))
                 单条记录) 
            *书籍数据库*)))
;call
;(更新 (筛选条件 :作者 "李白") :价格 10)
删除记录
(defun 删除 (根据?查找函数)
    (setf *书籍数据库*
        (remove-if 根据?查找函数 *书籍数据库*)))
;call
(删除 (筛选条件 :作者 "李刚"))
;;-------------------------------------------进阶抽象---------------------------------------------
;`表示该表达式不求值,里面逗号后面是求值的
;构造单条域值判断
(defun 域值->表达式 (域 值)
    `(equal (getf 单条记录 ,域) ,值))
;call
;(域值->表达式 "域" "值")
;(EQUAL (GETF 单条记录 "域") "值")
;构造多条域值判断
(defun 域值->列表 (域值参数对列表)
    (loop while 域值参数对列表
        collecting (域值->表达式 (pop 域值参数对列表) (pop 域值参数对列表))))
;call
;(域值->列表 '(:作者 "李白" :价格 1))
;((EQUAL (GETF 单条记录 :作者) "李白") (EQUAL (GETF 单条记录 :价格) 1))
;利用宏来构造筛选lambda表达式去除冗余
;把函数"域值->列表"返回的列表用 and 函数封装起来，
;具体来说就是把它构造出来的所有equal 语句都用 and 组装起来，最后再放入一个匿名函数中
(defmacro 筛选条件 (&rest 域值参数对列表)
    `#'(lambda (单条记录) 
            (and ,@(域值->列表 域值参数对列表))))
;使用macroexpand-1函数查看我们构造的宏打开后的代码,查看是否正确
;(macroexpand-1 '(筛选条件 :作者 "李白" :价格 1))
;#'(LAMBDA (单条记录) (AND (EQUAL (GETF 单条记录 :作者) "李白") (EQUAL (GETF 单条记录 :价格) 1)))
;;抽象 更新部分
;更新域值表达式
(defun 更新域值->表达式 (域 值)
  `(setf (getf 单条记录 ,域) ,值))
;更新域值表达式列表
(defun 更新域值->列表 (域值参数对列表)
    (loop while 域值参数对列表
        collecting (更新域值->表达式 (pop 域值参数对列表) (pop 域值参数对列表))))
;;使用宏构造lambda,连接条件
;注意其中根据?查找函数处需要用逗号(这里需要被求值得出筛选条件)
(defmacro 更新宏 (根据?查找函数 &rest 域值参数对列表)
    `(setf *书籍数据库*
        (mapcar
            #'(lambda (单条记录)
                (when (funcall ,根据?查找函数 单条记录)
                    ,@(更新域值->列表 域值参数对列表))
                 单条记录) 
            *书籍数据库*)))
;call
;(更新宏 (筛选条件 :作者 "李白" :价格 2) :价格 10 :是否有电子版 nil)
